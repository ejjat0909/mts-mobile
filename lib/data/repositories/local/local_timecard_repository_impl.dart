import 'dart:convert';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:mts/core/services/hive_sync_helper.dart';
import 'package:mts/core/storage/hive_box_manager.dart';
import 'package:mts/data/datasources/local/database_helpers.dart';
import 'package:mts/data/models/user/user_model.dart';
import 'package:mts/data/repositories/local/local_pending_changes_repository_impl.dart';
import 'package:mts/data/repositories/local/local_shift_repository_impl.dart';
import 'package:mts/core/utils/id_utils.dart';
import 'package:mts/core/utils/log_utils.dart';
import 'package:mts/data/datasources/local/database_helpers_interface.dart';
import 'package:mts/data/models/pending_changes/pending_changes_model.dart';
import 'package:mts/data/models/shift/shift_model.dart';
import 'package:mts/data/models/time_card/timecard_model.dart';
import 'package:mts/domain/repositories/local/pending_changes_repository.dart';
import 'package:mts/domain/repositories/local/shift_repository.dart';
import 'package:mts/domain/repositories/local/timecard_repository.dart';
import 'package:sqflite/sqflite.dart';

final timeCardBoxProvider = Provider<Box<Map>>((ref) {
  return HiveBoxManager.getValidatedBox(TimecardModel.modelBoxName);
});

/// ================================
/// Provider for Local Repository
/// ================================
final timecardLocalRepoProvider = Provider<LocalTimecardRepository>((ref) {
  return LocalTimecardRepositoryImpl(
    dbHelper: ref.read(databaseHelpersProvider),
    pendingChangesRepository: ref.read(pendingChangesLocalRepoProvider),
    shiftRepository: ref.read(shiftLocalRepoProvider),
    hiveBox: ref.read(timeCardBoxProvider),
  );
});

/// ================================
/// Local Repository Implementation
/// ================================
/// Implementation of [LocalTimecardRepository] that uses local database
class LocalTimecardRepositoryImpl implements LocalTimecardRepository {
  final IDatabaseHelpers _dbHelper;
  final LocalPendingChangesRepository _pendingChangesRepository;
  final LocalShiftRepository _shiftRepository;
  final Box<Map> _hiveBox;

  /// Database table and column names
  static const String tableName = 'timecards';
  static const String cId = 'id';
  static const String staffId = 'staff_id';
  static const String cShiftId = 'shift_id';
  static const String outletId = 'outlet_id';
  static const String clockIn = 'clock_in';
  static const String clockOut = 'clock_out';
  static const String totalHour = 'total_hour';
  static const String createdAt = 'created_at';
  static const String updatedAt = 'updated_at';

  /// Constructor
  LocalTimecardRepositoryImpl({
    required IDatabaseHelpers dbHelper,
    required LocalPendingChangesRepository pendingChangesRepository,
    required LocalShiftRepository shiftRepository,
    required Box<Map> hiveBox,
  }) : _dbHelper = dbHelper,
       _shiftRepository = shiftRepository,
       _hiveBox = hiveBox,
       _pendingChangesRepository = pendingChangesRepository;

  /// Create the timecard table in the database
  static Future<void> createTable(Database db) async {
    String rows = '''
      $cId TEXT PRIMARY KEY,
      $staffId TEXT NULL,
      $outletId TEXT NULL,
      $cShiftId TEXT NULL,
      $clockIn TIMESTAMP NULL,
      $clockOut TIMESTAMP NULL,
      $totalHour FLOAT NULL,
      $createdAt TIMESTAMP DEFAULT NULL,
      $updatedAt TIMESTAMP DEFAULT NULL
    ''';
    await IDatabaseHelpers.createTable(tableName, rows, db);
  }

  /// Insert a new timecard
  @override
  Future<int> insert(
    TimecardModel model, {
    required bool isInsertToPending,
  }) async {
    ShiftModel shiftModel = await _shiftRepository.getLatestShift();
    model.shiftId = shiftModel.id;
    model.id ??= IdUtils.generateUUID();
    model.updatedAt = DateTime.now();
    model.createdAt = DateTime.now();
    int result = await _dbHelper.insertDb(tableName, model.toJson());
    await _hiveBox.put(model.id, model.toJson());
    // Insert to pending changes if required
    if (isInsertToPending) {
      final pendingChange = PendingChangesModel(
        operation: 'created',
        modelName: TimecardModel.modelName,
        modelId: model.id,
        data: jsonEncode(model.toJson()),
      );
      await _pendingChangesRepository.insert(pendingChange);
    }

    return result;
  }

  // insert bulk
  @override
  Future<bool> upsertBulk(
    List<TimecardModel> list, {
    required bool isInsertToPending,
  }) async {
    try {
      Database db = await _dbHelper.database;
      final batch = db.batch();
      final List<PendingChangesModel> pendingList = [];

      for (var model in list) {
        // Note: id is auto-generated by SQLite (INTEGER PRIMARY KEY)

        batch.insert(
          tableName,
          model.toJson(),
          conflictAlgorithm: ConflictAlgorithm.replace,
        );

        if (isInsertToPending) {
          pendingList.add(
            PendingChangesModel(
              operation: 'created',
              modelName: UserModel.modelName,
              modelId: model.id!.toString(),
              data: jsonEncode(model.toJson()),
            ),
          );
        }
      }

      await batch.commit(noResult: true);

      // Bulk insert to Hive
      final dataMap = <dynamic, Map<dynamic, dynamic>>{};
      for (var model in list) {
        if (model.id != null) {
          dataMap[model.id!] = model.toJson();
        }
      }
      await _hiveBox.putAll(dataMap);

      for (var pending in pendingList) {
        await _pendingChangesRepository.insert(pending);
      }

      return true;
    } catch (e) {
      await LogUtils.error('Error bulk inserting user', e);
      return false;
    }
  }

  // update
  @override
  Future<int> update(
    TimecardModel model, {
    required bool isInsertToPending,
  }) async {
    try {
      // Update SQLite
      int result = await _dbHelper.updateDb(tableName, model.toJson());

      // Update Hive
      await _hiveBox.put(model.id!.toString(), model.toJson());

      if (isInsertToPending) {
        final pendingChange = PendingChangesModel(
          operation: 'updated',
          modelName: TimecardModel.modelName,
          modelId: model.id,
          data: jsonEncode(model.toJson()),
        );
        await _pendingChangesRepository.insert(pendingChange);
      }
      return result;
    } catch (e) {
      await LogUtils.error('Error updating user', e);
      rethrow;
    }
    // Insert to pending changes if required
  }

  // delete
  @override
  Future<int> delete(String id, {required bool isInsertToPending}) async {
    // Get the model before deleting it
    Database db = await _dbHelper.database;
    List<Map<String, dynamic>> results = await db.query(
      tableName,
      where: '$cId = ?',
      whereArgs: [id],
    );

    if (results.isNotEmpty) {
      final model = TimecardModel.fromJson(results.first);

      // Delete the record
      await _hiveBox.delete(id);
      int result = await _dbHelper.deleteDb(tableName, id);

      // Insert to pending changes if required
      if (isInsertToPending) {
        final pendingChange = PendingChangesModel(
          operation: 'deleted',
          modelName: TimecardModel.modelName,
          modelId: model.id,
          data: jsonEncode(model.toJson()),
        );
        await _pendingChangesRepository.insert(pendingChange);
      }

      return result;
    } else {
      prints('No timecard record found with id: $id');
      return 0;
    }
  }

  // delete bulk
  @override
  Future<bool> deleteBulk(
    List<TimecardModel> list, {
    required bool isInsertToPending,
  }) async {
    Database db = await _dbHelper.database;
    List<String> ids = list.map((e) => e.id!).toList();

    try {
      // If we need to insert to pending changes, we need to get the models first
      if (isInsertToPending) {
        for (TimecardModel timecard in list) {
          List<Map<String, dynamic>> results = await db.query(
            tableName,
            where: '$cId = ?',
            whereArgs: [timecard.id],
          );

          if (results.isNotEmpty) {
            final model = TimecardModel.fromJson(results.first);

            // Insert to pending changes
            final pendingChange = PendingChangesModel(
              operation: 'deleted',
              modelName: TimecardModel.modelName,
              modelId: model.id!,
              data: jsonEncode(model.toJson()),
            );
            await _pendingChangesRepository.insert(pendingChange);
          }
        }
      }

      // Now delete the records
      String whereIn = ids.map((_) => '?').join(',');
      await _hiveBox.deleteAll(ids);
      await db.delete(tableName, where: '$cId IN ($whereIn)', whereArgs: ids);
      return true;
    } catch (e) {
      prints('Error deleting bulk time card: $e');
      return false;
    }
  }

  // delete all
  @override
  Future<bool> deleteAll() async {
    try {
      // Delete from SQLite
      final db = await _dbHelper.database;
      await db.delete(tableName);

      // Delete from Hive
      await _hiveBox.clear();

      return true;
    } catch (e) {
      await LogUtils.error('Error deleting all timecard', e);
      return false;
    }
  }

  // get list time card
  @override
  Future<List<TimecardModel>> getListTimeCard() async {
    List<TimecardModel> list = HiveSyncHelper.getListFromBox(
      box: _hiveBox,
      fromJson: (json) => TimecardModel.fromJson(json),
    );
    if (list.isNotEmpty) {
      return list;
    }
    final List<Map<String, dynamic>> maps = await _dbHelper.readDb(tableName);
    return List.generate(maps.length, (index) {
      return TimecardModel.fromJson(maps[index]);
    });
  }

  @override
  Future<TimecardModel> getCurrentTimecard(String idStaff) async {
    List<TimecardModel> list = HiveSyncHelper.getListFromBox(
      box: _hiveBox,
      fromJson: (json) => TimecardModel.fromJson(json),
    );

    if (list.isNotEmpty) {
      return list.firstWhere(
        (element) =>
            element.staffId == idStaff &&
            element.clockOut == null &&
            element.clockIn != null,
        orElse: () => TimecardModel(),
      );
    }
    Database db = await _dbHelper.database;
    List<Map<String, dynamic>> maps = await db.query(
      tableName,
      where: '$staffId = ? AND $clockOut IS NULL AND $clockIn IS NOT NULL',
      whereArgs: [idStaff],
    );
    if (maps.isNotEmpty) {
      return TimecardModel.fromJson(maps.last);
    } else {
      return TimecardModel();
    }
  }

  @override
  Future<bool> replaceAllData(
    List<TimecardModel> newData, {
    bool isInsertToPending = false,
  }) async {
    try {
      final db = await _dbHelper.database;
      await db.delete(tableName); // Delete all rows from SQLite
      await _hiveBox.clear(); // Clear Hive
      return await upsertBulk(newData, isInsertToPending: isInsertToPending);
    } catch (e) {
      await LogUtils.error('Error replacing all timecard', e);
      return false;
    }
  }
}
