import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:mts/core/services/hive_sync_helper.dart';
import 'package:mts/core/storage/hive_box_manager.dart';
import 'package:mts/data/datasources/local/database_helpers.dart';
import 'package:mts/core/utils/log_utils.dart';
import 'package:mts/data/datasources/local/database_helpers_interface.dart';
import 'package:mts/data/models/downloaded_file/downloaded_file_model.dart';
import 'package:mts/data/models/receipt_setting/receipt_settings_model.dart';
import 'package:mts/domain/repositories/local/downloaded_file_repository.dart';
import 'package:sqflite/sqflite.dart';

final downloadedFileBoxProvider = Provider<Box<Map>>((ref) {
  return HiveBoxManager.getValidatedBox(DownloadedFileModel.modelBoxName);
});

/// ================================
/// Provider for Local Repository
/// ================================
final downloadedFileLocalRepoProvider = Provider<LocalDownloadedFileRepository>(
  (ref) {
    return LocalDownloadedFileRepositoryImpl(
      dbHelper: ref.read(databaseHelpersProvider),
      hiveBox: ref.read(downloadedFileBoxProvider),
    );
  },
);

/// ================================
/// Local Repository Implementation
/// ================================
/// Implementation of [LocalDownloadedFileRepository] that uses local database
class LocalDownloadedFileRepositoryImpl
    implements LocalDownloadedFileRepository {
  final IDatabaseHelpers _dbHelper;
  final Box<Map> _hiveBox;

  /// Database table and column names
  static const String tableName = 'downloaded_files';
  static const String cId = 'id';
  static const String nameModel = 'name_model';
  static const String modelId = 'model_id';
  static const String fileName = 'file_name';
  static const String url = 'url';
  static const String path = 'path';
  static const String isDownloaded = 'is_downloaded';
  static const String createdAt = 'created_at';
  static const String updatedAt = 'updated_at';

  /// Constructor
  LocalDownloadedFileRepositoryImpl({
    required IDatabaseHelpers dbHelper,
    required Box<Map> hiveBox,
  }) : _dbHelper = dbHelper,
       _hiveBox = hiveBox;

  /// Create the downloaded files table in the database
  static Future<void> createTable(Database db) async {
    String rows = '''
      $cId TEXT PRIMARY KEY,
      $nameModel TEXT NULL,
      $modelId TEXT NULL,
      $fileName TEXT NULL,
      $url TEXT NULL,
      $path TEXT NULL,
      $isDownloaded INTEGER DEFAULT 0,
      $createdAt TIMESTAMP DEFAULT NULL,
      $updatedAt TIMESTAMP DEFAULT NULL
    ''';
    await IDatabaseHelpers.createTable(tableName, rows, db);
  }

  @override
  Future<int> insert(
    DownloadedFileModel model, {
    required bool isInsertToPending,
  }) async {
    // Note: id is auto-generated by SQLite (INTEGER PRIMARY KEY)
    model.createdAt = DateTime.now();
    model.updatedAt = DateTime.now();

    try {
      // Insert to SQLite
      int result = await _dbHelper.insertDb(tableName, model.toJson());

      // Insert to Hive
      await _hiveBox.put(model.id!.toString(), model.toJson());

      return result;
    } catch (e) {
      await LogUtils.error('Error inserting customer', e);
      rethrow;
    }
  }

  @override
  Future<int> update(
    DownloadedFileModel model, {
    required bool isInsertToPending,
  }) async {
    model.updatedAt = DateTime.now();

    try {
      // Update SQLite
      int result = await _dbHelper.updateDb(tableName, model.toJson());

      // Update Hive
      await _hiveBox.put(model.id!.toString(), model.toJson());

      return result;
    } catch (e) {
      await LogUtils.error('Error updating customer', e);
      rethrow;
    }
  }

  @override
  Future<int> delete(String id, {required bool isInsertToPending}) async {
    // Get single item efficiently instead of fetching all

    HiveSyncHelper.getById(
          box: _hiveBox,
          id: id,
          fromJson: (json) => DownloadedFileModel.fromJson(json),
        ) ??
        DownloadedFileModel(id: id);

    try {
      // Delete from SQLite
      int result = await _dbHelper.deleteDb(tableName, id);

      // Delete from Hive
      await _hiveBox.delete(id);

      return result;
    } catch (e) {
      await LogUtils.error('Error deleting customer', e);
      rethrow;
    }
  }

  // ==================== Bulk Operations ====================

  @override
  Future<bool> upsertBulk(
    List<DownloadedFileModel> list, {
    required bool isInsertToPending,
  }) async {
    try {
      Database db = await _dbHelper.database;
      final batch = db.batch();

      for (var model in list) {
        // Note: id is auto-generated by SQLite (INTEGER PRIMARY KEY)
        model.createdAt ??= DateTime.now();
        model.updatedAt ??= DateTime.now();

        batch.insert(
          tableName,
          model.toJson(),
          conflictAlgorithm: ConflictAlgorithm.replace,
        );
      }

      await batch.commit(noResult: true);

      // Bulk insert to Hive
      final dataMap = <dynamic, Map<dynamic, dynamic>>{};
      for (var model in list) {
        if (model.id != null) {
          dataMap[model.id!] = model.toJson();
        }
      }
      await _hiveBox.putAll(dataMap);

      return true;
    } catch (e) {
      await LogUtils.error('Error bulk inserting customers', e);
      return false;
    }
  }

  @override
  Future<bool> deleteBulk(
    List<DownloadedFileModel> listCity, {
    required bool isInsertToPending,
  }) async {
    try {
      for (var city in listCity) {
        if (city.id != null) {
          await delete(
            city.id.toString(),
            isInsertToPending: isInsertToPending,
          );
        }
      }
      return true;
    } catch (e) {
      await LogUtils.error('Error deleting bulk cities', e);
      return false;
    }
  }

  @override
  Future<List<DownloadedFileModel>> getListDownloadedFile() async {
    // ✅ Try Hive first
    final hiveList = HiveSyncHelper.getListFromBox(
      box: _hiveBox,
      fromJson: (json) => DownloadedFileModel.fromJson(json),
    );

    if (hiveList.isNotEmpty) {
      return hiveList;
    }

    // Fallback to SQLite
    final List<Map<String, dynamic>> maps = await _dbHelper.readDb(tableName);
    return List.generate(maps.length, (index) {
      return DownloadedFileModel.fromJson(maps[index]);
    });
  }

  @override
  Future<DownloadedFileModel?> getDownloadedFileByUrl(String fileUrl) async {
    // ✅ Try Hive first using HiveSyncHelper
    final hiveList = HiveSyncHelper.getListFromBox(
      box: _hiveBox,
      fromJson: (json) => DownloadedFileModel.fromJson(json),
    );

    if (hiveList.isNotEmpty) {
      return hiveList
          .where(
            (element) =>
                element.url == fileUrl &&
                element.path != null &&
                element.isDownloaded == true,
          )
          .firstOrNull;
    }

    // Fallback to SQLite
    Database db = await _dbHelper.database;
    List<Map<String, dynamic>> results = await db.query(
      tableName,
      where: '$url = ? AND $isDownloaded = 1 AND $path IS NOT NULL',
      whereArgs: [fileUrl],
    );
    if (results.isNotEmpty) {
      return DownloadedFileModel.fromJson(results.first);
    } else {
      return null;
    }
  }

  @override
  Future<List<DownloadedFileModel>> getDownloadedFilesByModelId(
    String idModel,
  ) async {
    // ✅ Try Hive first using HiveSyncHelper
    final hiveList = HiveSyncHelper.getListFromBox(
      box: _hiveBox,
      fromJson: (json) => DownloadedFileModel.fromJson(json),
    );

    if (hiveList.isNotEmpty) {
      return hiveList.where((element) => element.modelId == idModel).toList();
    }

    // Fallback to SQLite
    Database db = await _dbHelper.database;
    List<Map<String, dynamic>> results = await db.query(
      tableName,
      where: '$modelId = ?',
      whereArgs: [idModel],
    );

    return List.generate(results.length, (index) {
      return DownloadedFileModel.fromJson(results[index]);
    });
  }

  @override
  Future<DownloadedFileModel> getPrintedLogoPath() async {
    // ✅ Try Hive first using HiveSyncHelper
    final hiveList = HiveSyncHelper.getListFromBox(
      box: _hiveBox,
      fromJson: (json) => DownloadedFileModel.fromJson(json),
    );

    if (hiveList.isNotEmpty) {
      return hiveList.firstWhere(
        (element) =>
            element.nameModel == ReceiptSettingsModel.printedEntity &&
            element.path != null,
        orElse: () => DownloadedFileModel(),
      );
    }

    // Fallback to SQLite
    Database db = await _dbHelper.database;
    List<Map<String, dynamic>> results = await db.query(
      tableName,
      where: '$nameModel = ? AND $path IS NOT NULL',
      whereArgs: [ReceiptSettingsModel.printedEntity],
    );

    if (results.isNotEmpty) {
      final downloadedFileModel = DownloadedFileModel.fromJson(results.first);
      return downloadedFileModel;
    } else {
      return DownloadedFileModel();
    }
  }

  @override
  Future<DownloadedFileModel> getByImagePathAndUrl({
    required String imagePath,
    required String downloadUrl,
  }) async {
    // ✅ Try Hive first using HiveSyncHelper
    final hiveList = HiveSyncHelper.getListFromBox(
      box: _hiveBox,
      fromJson: (json) => DownloadedFileModel.fromJson(json),
    );

    if (hiveList.isNotEmpty) {
      return hiveList.firstWhere(
        (element) =>
            element.fileName == imagePath && element.url == downloadUrl,
        orElse: () => DownloadedFileModel(),
      );
    }

    // Fallback to SQLite
    Database db = await _dbHelper.database;
    try {
      final List<Map<String, dynamic>> results = await db.query(
        tableName,
        where: '$fileName = ? AND $url = ?',
        whereArgs: [imagePath, downloadUrl],
      );

      if (results.isNotEmpty) {
        return DownloadedFileModel.fromJson(results.first);
      } else {
        return DownloadedFileModel();
      }
    } catch (e) {
      prints(e);
      return DownloadedFileModel();
    }
  }
}
